# Server_Clients_Practice
서버-클라이언트 구조 맛보기 부터

## 미니 프로젝트 : 1:1 오목대전 구현

### ver 1.0 : 4회차 작업 250304


https://github.com/user-attachments/assets/1f049782-0463-4c84-a53a-4245a55445a8


- 업데이트 내용
  - 게임 종료 후, 1회만 게임이 다시시작되고 2회차 부터는 다시시작되지 않는 버그 수정
  - 3,3 을 막는 로직 구현. (4,3 등은 실행됨)
  - 3,3 을 시도할 시 TEXT 렌더링 추가

- [서버](./game_omok/server.py)
- [클라이언트](./game_omok/main.py)

### ver 0.5 : 3회차 작업 250302


https://github.com/user-attachments/assets/f87eabd7-2713-48f7-88a3-c38ba72100db


- 업데이트 내용 : 게임 승 패 로직 구현 , 본인의 턴 알려주는 UI구현 , 게임 재시작 기능
- 짬짬히 개발하는데 머리가 터질거같은 난관을 만나고, 그걸 해결하는 맛이 있다.
- 4회차 업데이트 예정 : AWS 혹은 구글 클라우드 활용하여, 서버를 열고 실제 게임 배포 후 프로젝트 마무리 예정

- 개발일지 : 학창시절 노트에 격자를 그려서 했던 그 만만한 게임인 오목의 승 패를 구분하는 로직이 이렇게 머리아플 줄 몰랐다.
처음에 무식하게 board에 저장된 2중배열을 순회해서 0이 들어있으면 pass 1이나 2가있으면 그때부터 8방향으로 찾는 로직을 생각 했는데, 나 같은 초보가 봐도 시간복잡도가 말이 안되는, 렉 오지는 게임이 될거 같았다. 그래서 해결방법을 고민하던 도중 얼마 전 알고리즘 수업에서 공부한 동적프로그래밍 DP 개념이 떠올랐다. 메모이제이션을 활용해 중복 계산을 줄이고 새로 놓이는 돌을 기준으로 탐색, 그리고 연결만 해주면 되었다. 물론 개념은 쉽지, 실제 구현은 노트에 손으로 쓱쓱 그려가며 한땀한땀 했다는사실;
그래도 공부한 것을 실제로 써먹어보며 한 걸음씩 성장하고 있다는 것을 느껴보는 업데이트였다.

### ver 0.3 : 2회차 작업 250301


https://github.com/user-attachments/assets/765bc276-daa5-400a-a8e4-a216f04ea45d


- 업데이트 내용 : 2명의 플레이어가 모두 connect 되면 게임이 실행하도록 로직 변경
- 빡빡한 일정으로 인해, 간단 업데이트 .. 아쉽
- 3회차 업데이트 예정 : 게임 승 패 로직 , 본인의 턴 알려주는 UI

- 개발일지 : 아직 익숙치 않은 프로그래밍 방식이여서, 서버와 클라 모두가 공유하는 외부변수 flag를 관리해야지 라는 생각으로 접근했다가, 무언가 굳이 안해도 될 통신을 계속 주고받고있는듯한 느낌을 받았다. (무언가 비효율적인 쎄한 느낌..)
그래서 클라이언트에 전역변수로 flag를 설정하고 프로그램 실행 시 계속 준비되었냐고 서버에게 물어보고 , 서버측에 플레이어가 2명이 되지 않았다면 False를 돌려주고 , 준비되었다면 True를 돌려주어 클라이언트에서 flag를 딸깍 딸깍 바꾸어주는 로직으로 변경했다. 처음에는 move 를 호출 할때마다 변경되도록 하는 바보같은 짓을 했다, 이 를 깨닫고 수정하는 과정에서 게임이 돌아가는 시스템에 대해 좀 더 이해하게 되었다.


### ver 0.1 : 1회차 작업 250228

https://github.com/user-attachments/assets/cac6a10c-6a93-47aa-b1fc-05e908e6155c


- server.py
  - flask 로 서버를 열고 실시간 통신을 위해 flask_socketio로 통신 구현
  - 서버측에서는 @socketio.on('keyword')를 통해 메시지를 주고 받는다.

- main.py
  - pygame을 통해 간단한 UI 구현, socketio 를 통해 서버와 통신을 주고받음
  - 클라이언트 측에서는 @sio.on('keyword')를 통해 메시지를 주고 받는다.

```python
# 기본적으로 sio.on('key'), socketio.on('key') 와 emit('key', 데이터) 를 통해 통신을 함
@sio.event
def connect():
  """서버 연결 됬을 시 행동"""
@sio.event
def disconnect():
  """연결 종료 시 행동"""
```

- 개발일지 : Flask가 뭐고, 소켓 프로그래밍이 뭔지 말만 들어보고, 혼자 KOCW 대학교 네트워크 강의를 들으면서 이론만 대충 알고 있었는데, 머리로는 구상이 되지만 막상 구현하려면 매번 막혀서 도망쳤었다. 그런데, **처음으로 서버를 열고 "서버에 연결됨" 메시지를 보았을 때, 카타르시스를 느꼇다.** 현재 게임은 버그 투성이이며 고칠 것도 많지만 오늘은 서버와 연동을 성공했고, 메시지를 성공적으로 주고받았다는 것에 의의를 두어본다. **이번 프로젝트는 완벽을 기하기 보다는 하고싶은거 다 해보며 서버-클라이언트 구조에 익숙해지는 시간을 갖는 것이 목표**이다, 역시 100번 강의 보다, 1번 강의 + 몸통박치기가 최고의 학습인것 같다.

- 2회차 할 것 정리
    - 플레이어 1,2 모두가 연결되면 게임 시작하는 기능
    - 오목 게임 승리 로직 구현
    - UI 이쁘게 꾸며보기


## Flask 기본 개념 이해
- Flask 란?
  - 가벼운 웹 프레임워크로, 웹 애플리케이션과 API 서버를 쉽게 만들 수 있다.
  - 요청을 처리하고 JSON 응답을 반환하는 REST API 서버를 개발할 때 많이 사용됨.
  - Django보다 간단한 구조를 가짐.

- 설치하기
  ```shell
  pip install flask
  ```

